---
output: 
html_document:
    keep_md: true
    toc: true
author: "Mark Klik & Misja Mikkers "
---

# Packages

For this notebook we need `tidyverse`.

```{r}
library(tidyverse)
```


# Introduction

In this notebook we will explore the use of control statements and functions. These concepts are an important part of more or less all programming languages. 

# Control statements

`R` has a limited number of control statements:

* `if`, `else` (of `ifelse`)
* `for`
* `repeat` / `while`
* `break`
* `next`
* `return`

With these statements you are able to run specific parts of your code, depending on a certain condition or you can run so called _loops_ in your notebook.

We will start with the `if` statement. The `if` statement determines if a condition is `TRUE` or `FALSE` and excute a certain part of the code depending on the outcome.

For example,

```{r}
x <- 6

if (x < 4) {
  print("smaller")  # first part of the code
} else {
  print("larger")  # second part of the code
}
```

Because `x` fullfills the second condition, the second part of the code will be executed.
To use a part of the code multiple times, you can use a `for` loop:


```{r}
for (counter in 1:5) {
  print(counter)
}
```

The same code-snippet will be executed 5 times, because the counter gets the value from 1 to 5
 (`1:5` is equivalent to `c(1, 2, 3, 4, 5)`). 
 
The inner part of a loop is called an iteration and usually it is run many times. You can skip to the next iteration with the command `next`.

```{r}
for (counter in 1:5) {
  if (counter == 3) next
  print(counter)
}
```

The iteration where `counter == 3` is not executed. If you want to stop the _for loop_ completely, you can use `break`:

```{r}
for (counter in 1:5) {
  if (counter == 3) break
  print(counter)
}
```

Alle interations after `counter == 2` are not executed.
Similar code can be produced with `while` and `repeat`. 

`while` allows you to run code until a condition is fullfilled:

```{r}
counter <- 1

while (counter <= 5) {
  print(counter)
  counter <- counter + 1
}
```

and:

```{r}
repeat {
  number <- sample(1:10, 1)
  print(number)
    if (number > 8) break
}
```

This prints random numbers until `number > 8`. 

Most people prefer `for` loops, therefore, you rarely see `while` and `repeat`.

> **Assignment**:
Construct a `for` loop that runs from 1 to 100 and test for each number if it can be divided by 2, 3 or 5. Count the numbers that are **not** divisible by 2,3 or 5 and print these numbers.
> _Hint: use the function `round` for the division test in combination with the `if` statement and the `next` statement_

```{r, eval=FALSE}
counter <- 0

for (number in  ...
```

```{r, echo=FALSE}
counter <- 0

for (number in 1:100)
{
  if (number / 2 == round(number / 2)) next
  
  if (number / 3 == round(number / 3)) next

  if (number / 5 == round(number / 5)) next

  counter <- counter + 1
  cat(number, " ")
}

print(counter)
```

The function `cat` is used for nicer output.

# Functions

`R` is build on functions. Most commands available from packages, are implemented with functions. Functions are used to automate the boring stuff...

Our first function:

```{r}
squared <- function(x) {
  x * x
}
```

The funtion `squared` returns the squared values of an input vector:

```{r}
squared(c(1,3))
```


Functions may have more arguments:

```{r}
squared_plus <- function(x, y) {
  x * x + y
}

squared_plus(3, 5)
```

This function uses two input variables and returns one output.


> **Assignment**: Create a variable with 2 'inputs' which pastes the two inputs with the function `paste`  and run an example with your function that pastes "house number" to the number 110
 
```{r, eval=FALSE}

plak <- function(...
```

```{r, echo=FALSE}
Paste <- function(x, y) {
  paste(x, y)
}

Paste("huisnummer", 110)  # paste two varibles

Paste("letter", LETTERS)  # the function also works with vectors
```


# Dataframe's

Our next function will operate on `data.frame`'s. Therefore, we first need to create a sample dataset. We will use information that resembles the risk adjustment system in the Netherlands.

We want to create a dataframe with 10.000 people so we first create the variable _number_of_persons_ and assign the number 10000 this variable.

Then we will create a dataframe with the name `dt` and add the following variables :

* _ID_: runs from 1 to 10000
* _Group_: number from 1 to 40
* _FKG_: FKG score (drugs)
* _DKG_: DKG score (diagnose)

_Group_ is a random number from 1 to 40. We will set `replace = TRUE`, otherwise we cannot assign the group numbers to 10.000 people. For _FKG_ and _DKG_ we will do the same.

`FKG == 0` means that a person did not use drugs, while `FKG == 1` means that a person used drugs. The same holds for _DKG_'s.



```{r}
number_of_persons <- 10000

dt <- data.frame(
  ID = 1:number_of_persons,
  Group = sample(1:40, number_of_persons, replace = TRUE),
  FKG = sample(0:1, number_of_persons, replace = TRUE),
  DKG = sample(0:1, number_of_persons, replace = TRUE))

head(dt)  
```


## What is the meaning of the variable _Group_ in this dataframe?

We now have a dataframe with 10000 persons. Each person has an _ID_ (number from 1 to 10000).

We know the group each person belongs to (number from 1 to 40)
Each group is a combination of age and gender according to the following rules:

* Group 1 to 20 are male
* Group 21 to 40 are females
* Group 1 is the age category from 0 to 4 jaar, group 2 from 5 to 9 jaar, etc.
* The same holds for females, starting from group 21


## The conditional statement `ifelse`

We created a datafile similar to a part of the Dutch Riskadjustment Scheme. The column group does not give much insight. Therefore, we would like to add a new column "gender". And we would like to make a column that indicates if a certain person is younger or older than 65. 
Males are in group 1-20, females in 21-40.

We need the following functions:

* `%>%`
* `mutate`
* `ifelse` 

The pipe operator `%>%` and the function `mutate` will be part of the datacamp `dplyr` course.

`%>%` is the pipe-operator. You can read the pipeoperator as "then". First we assign  `dt1` to `dt` and then...

`mutate` is the `dplyr` command to create a new variable (column).

`mutate(Gender = ...)` creates a new variable with the name "Gender". The `=` indicates how this variable is defined.

With `ifelse` we can create the condition male or female:

```{r}
dt1 <- dt %>%
  mutate(Gender = ifelse(Group <= 20, "male", "female")) %>%
  mutate(Elderly = ifelse(
    (Group >= 14 & Group <= 20) | (Group >= 34 & Group <= 40), "65+", "65-"))
  
```

The first part of the code reades as follows:

1.  Create a dataframe `dt1`, use dataframe `dt`, then
2.  create a new column `Gender`. If the group number (i.e. 1 - 40) is smaller or equal to twenty, give the value "male", else return value "female", then

We add a new variable "Elderly". This is slightly more complex, because a male is an elderly if he is located in groups 14-20. Females belong to the elderly if they are in groups 34-40.

`|` is the operator 'or'

So the code continues:

3.  create a new variable elderly. If the group number is larger or equal than 14 and is smaller than 20 OR the group number is larger than 34 and smaller than 40 return the value "65+" and else return value "65-"

With `str(dt1)` we can inspect the structure of the data.


```{r}
str(dt1)
```

With `summary(dt1)` we can have a summary of the data

```{r}
summary(dt1)
```

## To use a function

It is possible to classify people in age groups of 5 year with`ifelse()`. This could look something like this:



```{r}
dt1a <- dt1 %>%
  mutate(age_class = ifelse(Group== 1 | Group==21, "00-04",
                            ifelse(Group== 2 | Group==22, "05-09", 
                             ifelse(Group==3 | Group ==23, "10-14",
                                   "old"))))
head(dt1a)

```

This is very time consuming. If you need a code multiple times, you could use a function.



> **Assignment**: Create a function `age_category` which translates a a group into a age_category (i.e. age_category is a function of group)
Example: We would like to change the groupnumber 3 into a category "10-14".
Therefore, we need to change values into a text. We can do this with the existing function `paste0()`
(see the help files or [here](https://www.r-bloggers.com/difference-between-paste-and-paste0/))




```{r}

age_category <- function(group)
{
  age_start <- group * 5 - 5  # start age range
  age_end <- group * 5 - 1  # end age range
  
  age_label <- paste0(age_start, "-", age_end)  # text label
}
```

```{r, eval=FALSE}

age_category <- function(group)
{
  age_start <- ...
  age_end <- ...
  
  age_label <- paste0(...
}
```

This function should read:


1. Define parameter `age_start`. This should be equal to the group number multiplied with 5 minus 5.
3. The same holds for `age_end` , but then with minus 1  in stead of minus 5 
4. With `paste0` we can paste `age_start` and `age_end` with a minus between them. For group 1 we should receive a label '0-4' and group 14 should be translated in '65-69'. 

a.  Now you can print the age_category 3 and
b.  A vector of the age category 1:20


```{r}
# een enkele groep
print(age_category(3))

# een vector van groepen
print(age_category(1:20))
```

Now we are ready to apply our function to our dataframe and create a new column:

```{r}
dt2 <- dt1 %>%
  mutate(Age = ifelse(Group <= 20, age_category(Group), age_category(Group - 20)))

head(dt2)
```

The code reads:

1. Create a new dataframe `dt2`, which is equal to `dt1`, then....
2. Create a new column `Age` with `mutate`. For males (Group is smaller or equal to 20) we can use  use our function `age_category(Group)` directly. For females we can use the age category for the groupnumber minus 20. 

For the graded assignment 2 we need dt2. Therefore, we store the dataframe as csv in sourcedata.

```{r}
write.csv2(dt2, "../Sourcedata/graded_assignment_2.csv", row.names = FALSE)
```


# Homework

**nog niet vertaald!!!**

Het huiswerk is om een kolom 'GezondheidsStatus' te maken met "Gezond" en "Ongezond"

Een persoon is "Gezond", wanneer `FKG` 0 is en `DKG` 0 is.

Dus

| FKG | DKG | Status   |
|-----|-----|----------|
| 0   | 0   | gezond   |
| 1   | 0   | ongezond |
| 0   | 1   | ongezond |
| 1   | 1   | ongezond |

```{r, echo=FALSE}
dt3 <- dt2 %>%
  mutate(GezondheidsStatus = ifelse(DKG == 0 & FKG == 0, "Gezond", "Ongezond"))
```

```{r, eval=FALSE}
dt3 <- dt2 %>%
  mutate(...
```
